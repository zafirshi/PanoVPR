import os
from typing import List

import PIL
import torch
import faiss
import matplotlib.pyplot as plt
import logging
import numpy as np
from glob import glob
from tqdm import tqdm
from os.path import join
import torch.utils.data as data
import torchvision.transforms as transforms
from torch.utils.data.dataset import Subset
from sklearn.neighbors import NearestNeighbors
from torch.utils.data.dataloader import DataLoader
from tools.visual import path_to_pil_img

base_transform = transforms.Compose([
    transforms.ToTensor(),
    # transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),
])


def shift_window_on_descriptor(short_vector, long_matrix, window_size, divisor_factor, sorted_indices_num):
    """
    Shift window in descriptor comparing between short_query_vector and long_database_matrix,
    and calculate similarity in window range
    :param divisor_factor: window_stride=window_size/n. n->divisor_factor
    :param short_vector: a short numpy vector generated by query image
    :param long_matrix: a long and multi-row matrix(2d numpy array) generated by sampled negative images
    :param window_size: feature_window_length set as shifting base length
    :param sorted_indices_num: num of index we select from sorted candidate descriptors
    :return:
        sorted_indices_num_in_matrix: database index
        window_loc_in_matrix: focus patch in selected database matrix
    """
    left, right = 0, window_size
    window_stride = int(window_size / divisor_factor)

    part_distance_list = []
    width_bound = long_matrix.shape[1]
    counter = 0

    while left < width_bound:
        if right <= width_bound:
            part_distance = np.linalg.norm(short_vector - long_matrix[:, left:right], ord=2, axis=1)
        else:
            cycle_part = np.concatenate((long_matrix[:,left:],long_matrix[:,:right-width_bound]),axis=1)
            part_distance = np.linalg.norm(short_vector - cycle_part, ord=2, axis=1)
        part_distance_list.append(part_distance)

        left += window_stride
        right += window_stride
        counter += 1

    maintain_table = np.array(part_distance_list).transpose()

    # Select the smallest 'sorted_indices_num' 'long_matrix_index' based on distance
    sorted_indices_num_in_matrix = np.argsort(np.min(maintain_table, axis=1))[:sorted_indices_num]

    window_loc_in_matrix = np.argmin(maintain_table, axis=1)[sorted_indices_num_in_matrix]
    return sorted_indices_num_in_matrix, window_loc_in_matrix


def shift_window_on_img(img: torch.Tensor, win_num: int, win_stride: int, win_len: int) -> torch.Tensor:
    """
    shift window on picture
    :param img: tensor with long width, shape like be (3, 448, 3584)
    :param win_num: split window_num [should calculate carefully before training]
    :param win_stride: step window_shift
    :param win_len:
    :return:split_pano img -> a tensor shape like (N, 3, 448, 3584/N)
    """
    input_img_width = img.shape[-1]
    img_split_list = []
    for i in range(win_num):
        sw_left = i * win_stride
        sw_right = i * win_stride + win_len
        if sw_left <= input_img_width and sw_right <= input_img_width:
            img_split_list += [img[:, :, int(sw_left):int(sw_right)]]
        # when one-go directly, win_num should be 15(7+8) or other numbers
        # cycle calculate concat the rightest and  the leftest part
        elif sw_left <= input_img_width < sw_right:
            img_split_list += [torch.concat([img[:, :, int(sw_left):],
                                             img[:, :, :int(sw_right - input_img_width)]], dim=-1)]
        else:
            break
    img = torch.stack(img_split_list, dim=0)
    return img


class PCADataset(data.Dataset):
    def __init__(self, args, datasets_folder="dataset", dataset_folder="pitts30k/images/train"):
        dataset_folder_full_path = join(datasets_folder, dataset_folder)
        if not os.path.exists(dataset_folder_full_path):
            raise FileNotFoundError(f"Folder {dataset_folder_full_path} does not exist")
        self.images_paths = sorted(glob(join(dataset_folder_full_path, "**", "*.jpg"), recursive=True))

    def __getitem__(self, index):
        return base_transform(path_to_pil_img(self.images_paths[index]))

    def __len__(self):
        return len(self.images_paths)


class BaseDataset(data.Dataset):
    """Dataset with images from database and queries, used for inference (testing and building cache).
    """

    def __init__(self, args, datasets_folder="datasets", dataset_name="pitts30k", split="train"):
        super().__init__()
        self.args = args
        self.dataset_name = dataset_name
        self.dataset_folder = join(datasets_folder, dataset_name, "images", split)
        if not os.path.exists(self.dataset_folder): raise FileNotFoundError(
            f"Folder {self.dataset_folder} does not exist")

        self.resize = args.resize
        self.query_resize = args.query_resize
        self.database_resize = args.database_resize
        self.test_method = args.test_method

        self.split_nums = args.split_nums
        # Non-overlapping sliding window length (in pixels), default to the width of the perspective query image.
        self.window_len = self.resize[1]  
        self.window_stride = 8 * self.window_len / self.split_nums  # Pixel step length of the sliding window.
        if self.window_stride < self.window_len:
            logging.debug('[Note]:slide window using overlapping way')

        # for displayï¼Œlocate the selected window_num
        self.pos_focus_patch = []
        self.neg_focus_patch = []

        #### Read paths and UTM coordinates for all images.
        database_folder = join(self.dataset_folder, "database_pano_clean")
        queries_folder = join(self.dataset_folder, "queries_split")

        if not os.path.exists(database_folder): raise FileNotFoundError(f"Folder {database_folder} does not exist")
        if not os.path.exists(queries_folder): raise FileNotFoundError(f"Folder {queries_folder} does not exist")
        self.database_paths = sorted(glob(join(database_folder, "**", "*.jpg"), recursive=True))
        self.queries_paths = sorted(glob(join(queries_folder, "**", "*.jpg"), recursive=True))
        # The format must be path/to/file/@utm_easting@utm_northing@...@.jpg
        self.database_utms = np.array(
            [(path.split("@")[1], path.split("@")[2]) for path in self.database_paths]).astype(np.float)
        self.queries_utms = np.array([(path.split("@")[1], path.split("@")[2]) for path in self.queries_paths]).astype(
            np.float)

        # Find soft_positives_per_query, which are within val_positive_dist_threshold (deafult 25 meters)
        knn = NearestNeighbors(n_jobs=-1)
        knn.fit(self.database_utms)
        self.soft_positives_per_query = knn.radius_neighbors(self.queries_utms,
                                                             radius=args.val_positive_dist_threshold,
                                                             return_distance=False)

        self.images_paths = list(self.database_paths) + list(self.queries_paths)

        self.database_num = len(self.database_paths)
        self.queries_num = len(self.queries_paths)

    def __getitem__(self, index):
        if index < self.database_num:
            # split pano_database images into several subs
            img = path_to_pil_img(self.images_paths[index])
            img = self.resize_database_p2e(img)  # shape:(3,224,224*8)

        elif index >= self.database_num:
            # query image just resize
            img = path_to_pil_img(self.images_paths[index])
            img = base_transform(img)
            img = transforms.functional.resize(img, self.query_resize)
            # resize to adapt backbone input size
            img = transforms.functional.resize(img, self.resize)

        return img, index

    def resize_database_p2e(self, img: PIL.Image) -> torch.Tensor:
        img = base_transform(img)
        img = transforms.functional.resize(img, self.database_resize)
        img = transforms.functional.resize(img, (self.resize[0], 8 * self.resize[1]))  # shape:(3,224,224*8)
        return img

    def __len__(self):
        return len(self.images_paths)

    def __repr__(self):
        return (
            f"< {self.__class__.__name__}, {self.dataset_name} - #database: {self.database_num}; #queries: {self.queries_num} >")

    def get_positives(self):
        return self.soft_positives_per_query


class TripletsDataset(BaseDataset):
    """Dataset used for training, it is used to compute the triplets 
    with TripletsDataset.compute_triplets() with various mining methods.
    If is_inference == True, uses methods of the parent class BaseDataset,
    this is used for example when computing the cache, because we compute features
    of each image, not triplets.
    """

    def __init__(self, args, datasets_folder="datasets", dataset_name="pitts30k", split="train", negs_num_per_query=10):
        super().__init__(args, datasets_folder, dataset_name, split)
        self.mining = args.mining
        self.neg_samples_num = args.neg_samples_num  # Number of negatives to randomly sample
        self.negs_num_per_query = negs_num_per_query  # Number of negatives per query in each batch
        if self.mining == "full":  # "Full database mining" keeps a cache with last used negatives
            self.neg_cache = [np.empty((0,), dtype=np.int32) for _ in range(self.queries_num)]
        self.is_inference = False

        identity_transform = transforms.Lambda(lambda x: x)
        self.resized_transform = transforms.Compose([
            transforms.Resize(self.resize) if self.resize is not None else identity_transform,
            base_transform
        ])

        self.query_transform = transforms.Compose([
            transforms.ColorJitter(brightness=args.brightness) if args.brightness != None else identity_transform,
            transforms.ColorJitter(contrast=args.contrast) if args.contrast != None else identity_transform,
            transforms.ColorJitter(saturation=args.saturation) if args.saturation != None else identity_transform,
            transforms.ColorJitter(hue=args.hue) if args.hue != None else identity_transform,
            transforms.RandomPerspective(
                args.rand_perspective) if args.rand_perspective != None else identity_transform,
            transforms.RandomResizedCrop(size=self.resize, scale=(1 - args.random_resized_crop, 1)) \
                if args.random_resized_crop != None else identity_transform,
            transforms.RandomRotation(
                degrees=args.random_rotation) if args.random_rotation != None else identity_transform,
            self.resized_transform,
        ])

        # Find hard_positives_per_query, which are within train_positives_dist_threshold (10 meters)
        knn = NearestNeighbors(n_jobs=-1)
        knn.fit(self.database_utms)
        self.hard_positives_per_query = list(knn.radius_neighbors(self.queries_utms,
                                                                  radius=args.train_positives_dist_threshold,
                                                                  # 10 meters
                                                                  return_distance=False))

        #### Some queries might have no positive, we should remove those queries.
        queries_without_any_hard_positive = \
            np.where(np.array([len(p) for p in self.hard_positives_per_query], dtype=object) == 0)[0]
        if len(queries_without_any_hard_positive) != 0:
            logging.info(f"There are {len(queries_without_any_hard_positive)} queries without any positives " +
                         "within the training set. They won't be considered as they're useless for training.")
        # Remove queries without positives
        self.hard_positives_per_query = np.delete(self.hard_positives_per_query, queries_without_any_hard_positive)
        self.queries_paths = np.delete(self.queries_paths, queries_without_any_hard_positive)

        # Recompute images_paths and queries_num because some queries might have been removed
        self.images_paths = list(self.database_paths) + list(self.queries_paths)
        self.queries_num = len(self.queries_paths)

    
    def __getitem__(self, index):
        if self.is_inference:
            return super().__getitem__(index)
        query_index, best_positive_index, neg_indexes = torch.split(self.triplets_global_indexes[index],
                                                                    (1, 1, self.negs_num_per_query))

        query = self.query_transform(path_to_pil_img(self.queries_paths[query_index]))
        database_indices_list = torch.concat([best_positive_index, neg_indexes]).tolist()

        pano_database_list = [self.resize_database_p2e(each_pano_database) for each_pano_database in
                                [path_to_pil_img(self.database_paths[i]) for i in database_indices_list]]

        pano_database = torch.stack(pano_database_list, dim=0)
        return query, pano_database

    def __len__(self):
        if self.is_inference:
            return super().__len__()
        else:
            return len(self.triplets_global_indexes)

    def compute_triplets(self, args, model):
        self.is_inference = True
        
        if self.mining == "partial":
            self.compute_triplets_partial(args, model)
        elif self.mining == "full":
            raise NotImplementedError(f"{self.mining} has not been implemented yet, use partial instead")
        elif self.mining == "random":
            raise NotImplementedError(f"{self.mining} has not been implemented yet, use partial instead")
        else:
            raise KeyError(f"{self.mining} is not among the options (partial, full, random)")

    def compute_cache_database(self, args, model, subset_ds, database_cache_shape):
        """Compute the cache containing features of images, which is used to
        find best positive and hardest negatives."""

        subset_dl = DataLoader(dataset=subset_ds, num_workers=args.num_workers,
                               batch_size=args.infer_batch_size, shuffle=False,
                               pin_memory=(args.device == "cuda"))
        model = model.eval()

        # RAMEfficient2DMatrix can be replaced by np.zeros, but using
        # RAMEfficient2DMatrix is RAM efficient for full database mining.
        database_cache = RAMEfficient2DMatrix(database_cache_shape, dtype=np.float32)

        with torch.no_grad():
            for images, indexes in tqdm(subset_dl, ncols=100, desc='Compute Database Cache'):
                # images shape: 16(infer_bs),3,224,224*8 -> 16,16(split_num),3,224,224

                images = torch.stack([shift_window_on_img(each_img, win_num=self.split_nums,
                                                          win_stride=self.window_stride, win_len=self.window_len)
                                      for each_img in images])

                B, N, C, resize_H, resize_W = images.shape
                images = images.view(B * N, C, resize_H, resize_W)

                images = images.to(args.device)
                features = model(images)
                features = torch.flatten(features.view(B, N, -1), start_dim=1)

                database_cache[indexes.numpy()] = features.cpu().numpy()

        return database_cache

    @staticmethod
    def compute_cache_query(args, model, subset_ds, query_cache_shape, database_num):
        """Compute the cache containing features of images, which is used to
        find best positive and hardest negatives."""

        subset_dl = DataLoader(dataset=subset_ds, num_workers=args.num_workers,
                               batch_size=args.infer_batch_size, shuffle=False,
                               pin_memory=(args.device == "cuda"))
        model = model.eval()

        query_cache = RAMEfficient2DMatrix(query_cache_shape, dtype=np.float32)

        with torch.no_grad():
            for images, indexes in tqdm(subset_dl, ncols=100, desc='Compute Query Cache'):
                images = images.to(args.device)
                features = model(images)
                # minus to begin from 0
                query_cache[indexes.numpy() - database_num] = features.cpu().numpy()

        return query_cache

    def get_query_features(self, query_index, query_cache):
        query_features = query_cache[query_index]
        if query_features is None:
            raise RuntimeError(f"For query {self.queries_paths[query_index]} " +
                               f"with index {query_index} features have not been computed!\n" +
                               "There might be some bug with caching")
        return query_features

    def get_best_positive_index(self, args, query_index, database_cache, query_features) -> int:
        positives_features = database_cache[self.hard_positives_per_query[query_index]]

        # Segmentally compare the similarity between descriptors,
        # calculate the average row-wise (each row represents a panoramic image)
        best_positive_in_matrix, window_loc = shift_window_on_descriptor(short_vector=query_features,
                                                                         long_matrix=positives_features,
                                                                         window_size=args.features_dim,
                                                                         divisor_factor=args.reduce_factor,
                                                                         sorted_indices_num=1)

        # Search the best positive (within 10 meters AND nearest in features space)
        best_positive_index = self.hard_positives_per_query[query_index][best_positive_in_matrix]
        self.pos_focus_patch.append(window_loc)
        return best_positive_index.item()

    def get_hardest_negatives_indexes(self, args, database_cache, query_features, neg_samples):
        neg_features = database_cache[neg_samples]  # shape:(unknown, 8*feature_dim)

        neg_nums_in_matrix, window_loc = shift_window_on_descriptor(short_vector=query_features,
                                                                    long_matrix=neg_features,
                                                                    window_size=args.features_dim,
                                                                    divisor_factor=args.reduce_factor,
                                                                    sorted_indices_num=self.negs_num_per_query)

        neg_indexes = neg_samples[neg_nums_in_matrix]
        self.neg_focus_patch.append(window_loc)
        return neg_indexes.tolist()

    def compute_triplets_partial(self, args, model):
        triplets_global_indexes = []
        if self.mining == "partial":
            sampled_queries_indexes = np.random.choice(self.queries_num, args.cache_refresh_rate, replace=False)
        else:
            raise ValueError(f'sampled_queries_indexes is set wrong')

        sampled_database_indexes = np.random.choice(self.database_num, self.neg_samples_num, replace=False)
        # Take all the positives
        positives_indexes = [self.hard_positives_per_query[i] for i in sampled_queries_indexes]
        positives_indexes = [p for pos in positives_indexes for p in pos]
        # Merge them into database_indexes and remove duplicates
        database_indexes = list(sampled_database_indexes) + positives_indexes
        database_indexes = list(np.unique(database_indexes))

        subset_ds_database = Subset(self, database_indexes)
        subset_ds_query = Subset(self, list(sampled_queries_indexes + self.database_num))
        
        database_cache = self.compute_cache_database(args, model, subset_ds_database,
                                                     database_cache_shape=(
                                                         self.database_num, args.split_nums * args.features_dim))

        query_cache = self.compute_cache_query(args, model, subset_ds_query,
                                               query_cache_shape=(self.queries_num, args.features_dim),
                                               database_num=self.database_num)

        for query_index in tqdm(sampled_queries_indexes, ncols=100, desc='Neg Mining'):

            query_features = self.get_query_features(query_index, query_cache)
            best_positive_index = self.get_best_positive_index(args, query_index, database_cache, query_features)

            # Choose the hardest negatives within sampled_database_indexes, ensuring that there are no positives
            soft_positives = self.soft_positives_per_query[query_index]
            neg_indexes = np.setdiff1d(sampled_database_indexes, soft_positives, assume_unique=True)

            # Take all database images that are negatives and are within the sampled database images (aka database_indexes)
            neg_indexes = self.get_hardest_negatives_indexes(args, database_cache, query_features, neg_indexes)
            triplets_global_indexes.append((int(query_index), best_positive_index, *neg_indexes))

        self.triplets_global_indexes = torch.tensor(triplets_global_indexes)


class RAMEfficient2DMatrix:
    """This class behaves similarly to a numpy.ndarray initialized
    with np.zeros(), but is implemented to save RAM when the rows
    within the 2D array are sparse. In this case it's needed because
    we don't always compute features for each image, just for few of
    them"""

    def __init__(self, shape, dtype=np.float32):
        self.shape = shape
        self.dtype = dtype
        self.matrix = [None] * shape[0]

    def __setitem__(self, indexes, vals):
        assert vals.shape[1] == self.shape[1], f"{vals.shape[1]} {self.shape[1]}"
        for i, val in zip(indexes, vals):
            self.matrix[i] = val.astype(self.dtype, copy=False)

    def __getitem__(self, index):
        if hasattr(index, "__len__"):
            return np.array([self.matrix[i] for i in index])
        else:
            return self.matrix[index]
